<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory">Chapter 2. Architectural Overview</title><link rel="stylesheet" href="css/jbossorg.css" type="text/css"/><meta xmlns:rf="java:org.jboss.highlight.XhtmlRendererFactory" name="generator" content="DocBook XSL Stylesheets V1.74.0"/><link rel="home" href="index.html" title="The Netty Project 3.2 User Guide"/><link rel="up" href="index.html" title="The Netty Project 3.2 User Guide"/><link rel="prev" href="start.html" title="Chapter 1. Getting Started"/></head><body><p id="title"><a href="http://www.jboss.org/netty/" class="site_href"><strong>JBoss.org: Netty - The Client Server Framework and Tools</strong></a><a href="http://www.jboss.org/netty/documentation.html" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="start.html"><strong>Prev</strong></a></li><li class="next"/></ul><div class="chapter" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="architecture"/>Chapter 2. Architectural Overview</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="architecture.html#d0e1735">2.1. Rich Buffer Data Structure</a></span></dt><dt><span class="section"><a href="architecture.html#d0e1786">2.2. Universal Asynchronous I/O API</a></span></dt><dt><span class="section"><a href="architecture.html#d0e1838">2.3. Event Model based on the Interceptor Chain Pattern</a></span></dt><dt><span class="section"><a href="architecture.html#d0e1900">2.4. Advanced Components for More Rapid Development</a></span></dt><dd><dl><dt><span class="section"><a href="architecture.html#d0e1905">2.4.1. Codec framework</a></span></dt><dt><span class="section"><a href="architecture.html#d0e1916">2.4.2. SSL / TLS Support</a></span></dt><dt><span class="section"><a href="architecture.html#d0e1950">2.4.3. HTTP Implementation</a></span></dt><dt><span class="section"><a href="architecture.html#d0e1979">2.4.4. Google Protocol Buffer Integration</a></span></dt></dl></dd><dt><span class="section"><a href="architecture.html#d0e2001">2.5. Summary</a></span></dt></dl></div><div class="mediaobject" align="center"><img src="images/architecture.png" align="middle" alt="The Architecture Diagram of Netty"/></div><p>
    In this chapter, we will examine what core functionalities are provided in
    Netty and how they constitute a complete network application development
    stack on top of the core.  Please keep this diagram in mind as you read this
    chapter.
  </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1735"/>2.1. Rich Buffer Data Structure</h2></div></div></div><p>
      Netty uses its own buffer API instead of NIO <code class="classname">ByteBuffer</code>
      to represent a sequence of bytes. This approach has significant advantages
      over using <code class="classname">ByteBuffer</code>.  Netty's new buffer type,
      <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/buffer/ChannelBuffer.html"><code class="interfacename">ChannelBuffer</code></a> has been designed from the ground up to address the problems
      of <code class="classname">ByteBuffer</code> and to meet the daily needs of
      network application developers.  To list a few cool features:
      </p><div class="itemizedlist"><ul><li><p>
            You can define your own buffer type if necessary.
          </p></li><li><p>
            Transparent zero copy is achieved by a built-in composite buffer type.
          </p></li><li><p>
            A dynamic buffer type is provided out-of-the-box, whose capacity is
            expanded on demand, just like <code class="classname">StringBuffer</code>.
          </p></li><li><p>
            There's no need to call <code class="methodname">flip()</code> anymore.
          </p></li><li><p>
            It is often faster than <code class="classname">ByteBuffer</code>.
          </p></li></ul></div><p>
    </p><p>
      For more information, please refer to the
      <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/buffer/package-summary.html#package_description"><code class="literal">org.jboss.netty.buffer</code> package description</a>.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1786"/>2.2. Universal Asynchronous I/O API</h2></div></div></div><p>
      Traditional I/O APIs in Java provide different types and methods for
      different transport types.  For example,
      <code class="classname">java.net.Socket</code> and
      <code class="classname">java.net.DatagramSocket</code> do not have any common
      super type and therefore they have very different ways to perform socket
      I/O.
    </p><p>
      This mismatch makes porting a network application from one transport to
      another tedious and difficult.  The lack of portability between
      transports becomes a problem when you need to support additional
      transports, as this often entails rewriting the network layer of the
      application.  Logically, many protocols can run on more than one
      transport such as TCP/IP, UDP/IP, SCTP, and serial port communication.
    </p><p>
      To make matters worse, Java's New I/O (NIO) API introduced
      incompatibilities with the old blocking I/O (OIO) API and will continue
      to do so in the next release, NIO.2 (AIO).  Because all these APIs are
      different from each other in design and performance characteristics, you
      are often forced to determine which API your application will depend on
      before you even begin the implementation phase.
    </p><p>
      For instance, you might want to start with OIO because the number of
      clients you are going to serve will be very small and writing a socket
      server using OIO is much easier than using NIO.  However, you are going
      to be in trouble when your business grows exponentially and your server
      needs to serve tens of thousands of clients simultaneously.  You could
      start with NIO, but doing so may hinder rapid development by greatly
      increasing development time due to the complexity of the NIO Selector
      API.
    </p><p>
      Netty has a universal asynchronous I/O interface called a <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/Channel.html"><code class="interfacename">Channel</code></a>, which
      abstracts away all operations required for point-to-point communication.
      That is, once you wrote your application on one Netty transport, your
      application can run on other Netty transports.  Netty provides a number
      of essential transports via one universal API:
      </p><div class="itemizedlist"><ul><li><p>
            NIO-based TCP/IP transport
            (See <code class="literal">org.jboss.netty.channel.socket.nio</code>),
          </p></li><li><p>
            OIO-based TCP/IP transport
            (See <code class="literal">org.jboss.netty.channel.socket.oio</code>),
          </p></li><li><p>OIO-based UDP/IP transport, and</p></li><li><p>
            Local transport (See <code class="literal">org.jboss.netty.channel.local</code>).
          </p></li></ul></div><p>
      Switching from one transport to another usually takes just a couple
      lines of changes such as choosing a different <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelFactory.html"><code class="interfacename">ChannelFactory</code></a>
      implementation.
    </p><p>
      Also, you are even able to take advantage of new transports which aren't
      yet written (such as serial port communication transport), again
      by replacing just a couple lines of constructor calls.  Moreover, you can
      write your own transport by extending the core API.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1838"/>2.3. Event Model based on the Interceptor Chain Pattern</h2></div></div></div><p>
      A well-defined and extensible event model is a must for an event-driven
      application.  Netty has a well-defined event model focused on I/O.  It
      also allows you to implement your own event type without breaking the
      existing code because each event type is distinguished from another by
      a strict type hierarchy.  This is another differentiator against other
      frameworks.  Many NIO frameworks have no or a very limited notion of an
      event model. If they offer extension at all, they often break the
      existing code when you try to add custom event types
    </p><p>
      A <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelEvent.html"><code class="interfacename">ChannelEvent</code></a> is handled by a list of <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelHandler.html"><code class="interfacename">ChannelHandler</code></a>s in a
      <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelPipeline.html"><code class="interfacename">ChannelPipeline</code></a>. The pipeline implements an advanced form of the
      <a class="ulink" href="http://java.sun.com/blueprints/corej2eepatterns/Patterns/InterceptingFilter.html">Intercepting Filter</a>
      pattern to give a user full control over how an event is handled and how
      the handlers in the pipeline interact with each other.  For example,
      you can define what to do when data is read from a socket:
    </p><pre class="programlisting">public class MyReadHandler implements <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/SimpleChannelHandler.html"><code class="classname">SimpleChannelHandler</code></a> {
    public void messageReceived(<a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelHandlerContext.html"><code class="interfacename">ChannelHandlerContext</code></a> ctx, <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/MessageEvent.html"><code class="interfacename">MessageEvent</code></a> evt) {
        Object message = evt.getMessage();
        // Do something with the received message.
        ...

        // And forward the event to the next handler.
        ctx.sendUpstream(evt);
    }
}</pre><p>
      You can also define what to do when a handler receives a write request:
    </p><pre class="programlisting">public class MyWriteHandler implements <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/SimpleChannelHandler.html"><code class="classname">SimpleChannelHandler</code></a> {
    public void writeRequested(<a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelHandlerContext.html"><code class="interfacename">ChannelHandlerContext</code></a> ctx, <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/MessageEvent.html"><code class="interfacename">MessageEvent</code></a> evt) {
        Object message = evt.getMessage();
        // Do something with the message to be written.
        ...

        // And forward the event to the next handler.
        ctx.sendDownstream(evt);
    }
}</pre><p>
      For more information on the event model, please refer to the
      API documentation of <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelEvent.html"><code class="interfacename">ChannelEvent</code></a> and <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelPipeline.html"><code class="interfacename">ChannelPipeline</code></a>.
    </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e1900"/>2.4. Advanced Components for More Rapid Development</h2></div></div></div><p>
      On top of the core components mentioned above, that already enable the
      implementation of all types of network applications, Netty provides a set
      of advanced features to accelerate the page of development even more.
    </p><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1905"/>2.4.1. Codec framework</h3></div></div></div><p>
        As demonstrated in <a class="xref" href="start.html#start.pojo" title="1.8.  Speaking in POJO instead of ChannelBuffer">Section 1.8, “
      Speaking in POJO instead of ChannelBuffer
    ”</a>, it is always a good
        idea to separate a protocol codec from business logic. However, there
        are some complications when implementing this idea from scratch.  You
        have to deal with the fragmentation of messages. Some protocols are
        multi-layered (i.e. built on top of other lower level protocols). Some
        are too complicated to be implemented in a single state machine.
      </p><p>
        Consequently, a good network application framework should provide an
        extensible, reusable, unit-testable, and multi-layered codec framework
        that generates maintainable user codecs.
      </p><p>
        Netty provides a number of basic and advanced codecs to address most
        issues you will encounter when you write a protocol codec regardless
        if it is simple or not, binary or text - simply whatever.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1916"/>2.4.2. SSL / TLS Support</h3></div></div></div><p>
        Unlike old blocking I/O, it is a non-trivial task to support SSL in NIO.
        You can't simply wrap a stream to encrypt or decrypt data but you have
        to use <code class="classname">javax.net.ssl.SSLEngine</code>.
        <code class="classname">SSLEngine</code> is a state machine which is as complex
        as SSL itself.  You have to manage all possible states such as cipher
        suite and encryption key negotiation (or re-negotiation), certificate
        exchange, and validation.  Moreover, <code class="classname">SSLEngine</code> is
        not even completely thread-safe, as one would expect.
      </p><p>
        In Netty, <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/ssl/SslHandler.html"><code class="classname">SslHandler</code></a> takes care of all the gory details and pitfalls
        of <code class="classname">SSLEngine</code>.  All you need to do is to configure
        the <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/ssl/SslHandler.html"><code class="classname">SslHandler</code></a> and insert it into your <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/channel/ChannelPipeline.html"><code class="interfacename">ChannelPipeline</code></a>.  It also
        allows you to implement advanced features like
        <a class="ulink" href="http://en.wikipedia.org/wiki/Starttls">StartTLS</a>
        very easily.
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1950"/>2.4.3. HTTP Implementation</h3></div></div></div><p>
        HTTP is definitely the most popular protocol in the Internet. There are
        already a number of HTTP implementations such as a Servlet container.
        Then why does Netty have HTTP on top of its core?
      </p><p>
        Netty's HTTP support is very different from the existing HTTP libraries.
        It gives you complete control over how HTTP messages are exchanged at a
        low level.  Because it is basically the combination of an HTTP codec and
        HTTP message classes, there is no restriction such as an enforced thread
        model.  That is, you can write your own HTTP client or server that works
        exactly the way you want.  You have full control over everything that's
        in the HTTP specification, including the thread model, connection life
        cycle, and chunked encoding.
      </p><p>
        Thanks to its highly customizable nature, you can write a very efficient
        HTTP server such as:
        </p><div class="itemizedlist"><ul><li><p>
              Chat server that requires persistent connections and server push
              technology (e.g. <a class="ulink" href="http://en.wikipedia.org/wiki/Comet_%28programming%29">Comet</a>
              and <a class="ulink" href="http://en.wikipedia.org/wiki/WebSockets">WebSockets</a>)
            </p></li><li><p>
              Media streaming server that needs to keep the connection open
              until the whole media is streamed (e.g. 2 hours of video)
            </p></li><li><p>
              File server that allows the uploading of large files without
              memory pressure (e.g. uploading 1GB per request)
            </p></li><li><p>
              Scalable mash-up client that connects to tens of thousands of 3rd
              party web services asynchronously
            </p></li></ul></div><p>
      </p></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h3 class="title"><a id="d0e1979"/>2.4.4. Google Protocol Buffer Integration</h3></div></div></div><p>
        <a class="ulink" href="http://code.google.com/apis/protocolbuffers/docs/overview.html">Google Protocol Buffers</a>
        are an ideal solution for the rapid implementation of a highly efficient
        binary protocols that evolve over time.  With <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/codec/protobuf/ProtobufEncoder.html"><code class="classname">ProtobufEncoder</code></a> and
        <a class="ulink" href="http://docs.jboss.org/netty/3.2/api/org/jboss/netty/handler/codec/protobuf/ProtobufDecoder.html"><code class="classname">ProtobufDecoder</code></a>, you can turn the message classes generated by the
        Google Protocol Buffers Compiler (protoc) into Netty codec.  Please take
        a look into the
        <a class="ulink" href="http://docs.jboss.org/netty/3.2/xref/org/jboss/netty/example/localtime/package-summary.html">'LocalTime' example</a>
        that shows how easily you can create a high-performing binary protocol
        client and server from the
        <a class="ulink" href="http://anonsvn.jboss.org/repos/netty/trunk/src/main/java/org/jboss/netty/example/localtime/LocalTimeProtocol.proto">sample protocol definition</a>.
      </p></div></div><div class="section" lang="en-US"><div class="titlepage"><div><div><h2 class="title"><a id="d0e2001"/>2.5. Summary</h2></div></div></div><p>
      In this chapter, we reviewed the overall architecture of Netty from the
      feature standpoint.  Netty has a simple, yet powerful architecture.
      It is composed of three components - buffer, channel, and event model -
      and all advanced features are built on top of the three core components.
      Once you understood how these three work together, it should not be
      difficult to understand the more advanced features which were covered
      briefly in this chapter.
    </p><p>
      You might still have unanswered questions about what the overall
      architecture looks like exactly and how each of the features work
      together.  If so, it is a good idea to
      <a class="ulink" href="http://www.jboss.org/netty/community.html">talk to us</a> to improve this guide.
    </p></div></div><ul class="docnav"><li class="previous"><a accesskey="p" href="start.html"><strong>Prev</strong>Chapter 1. Getting Started</a></li><li class="up"><a accesskey="u" href="#"><strong>Top of page</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Front page</strong></a></li></ul></body></html>